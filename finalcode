private static (string, List<object>) BuildSafeFilterPredicate<T>(IEnumerable<KendoFilterDescriptor> filters)
{
    var parts = new List<string>();
    var values = new List<object>();

    foreach (var descriptor in filters)
    {
        foreach (var f in descriptor.Filters ?? [])
        {
            var idx = values.Count;
            string part;

            switch (f.Operator)
            {
                case "eq":
                    part = $"{f.Field} == @{idx}";
                    break;
                case "neq":
                    part = $"{f.Field} != @{idx}";
                    break;
                case "gt":
                    part = $"{f.Field} > @{idx}";
                    break;
                case "gte":
                    part = $"{f.Field} >= @{idx}";
                    break;
                case "lt":
                    part = $"{f.Field} < @{idx}";
                    break;
                case "lte":
                    part = $"{f.Field} <= @{idx}";
                    break;
                case "contains":
                    part = $"Convert.ToString({f.Field}).Contains(@{idx})";
                    break;
                case "doesnotcontain":
                    part = $"!Convert.ToString({f.Field}).Contains(@{idx})";
                    break;
                case "startswith":
                    part = $"Convert.ToString({f.Field}).StartsWith(@{idx})";
                    break;
                case "endswith":
                    part = $"Convert.ToString({f.Field}).EndsWith(@{idx})";
                    break;
                default:
                    part = $"{f.Field} == @{idx}";
                    break;
            }

            parts.Add(part);
            values.Add(f.Value);
        }
    }

    var predicate = string.Join(" and ", parts);
    return (predicate, values);
}
public static IQueryable<T> ApplyFiltering<T>(IQueryable<T> query, IEnumerable<KendoFilterDescriptor> filters)
{
    if (filters == null || !filters.Any())
        return query;

    bool requiresClientEval = filters.Any(f =>
        f.Filters.Any(inner =>
            inner.Operator is "contains" or "doesnotcontain" or "startswith" or "endswith"));

    // ⚠️ If contains-type filters exist, materialize to memory
    if (requiresClientEval)
    {
        var list = query.ToList(); // fetches from DB
        query = list.AsQueryable(); // switch to in-memory LINQ
    }

    var (predicate, values) = BuildSafeFilterPredicate<T>(filters);
    if (string.IsNullOrEmpty(predicate))
        return query;

    return query.Where(predicate, values.ToArray());
}

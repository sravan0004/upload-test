private static IQueryable<dynamic> ApplyFiltering(IQueryable<dynamic> query, IEnumerable<KendoFilterDescriptor> filters)
{
    var allPredicates = new List<string>();
    var allValues = new List<object>();

    foreach (var descriptor in filters)
    {
        if (descriptor.Filters == null) continue;

        var (predicate, values) = BuildFilterPredicate(descriptor);
        if (!string.IsNullOrWhiteSpace(predicate))
        {
            allPredicates.Add(predicate);
            allValues.AddRange(values);
        }
    }

    if (!allPredicates.Any())
        return query;

    var whereClause = string.Join(" and ", allPredicates);
    return query.Where(whereClause, allValues.ToArray());
}


private static (string Predicate, List<object> Values) BuildFilterPredicate(KendoFilterDescriptor descriptor)
{
    var parts = new List<string>();
    var values = new List<object>();

    foreach (var f in descriptor.Filters ?? Enumerable.Empty<KendoFilterItem>())
    {
        var idx = values.Count;
        string predicate;

        // Simplified operator handling: works across all types
        switch (f.Operator)
        {
            case "eq":
                predicate = $"{f.Field} == @{idx}";
                break;
            case "neq":
                predicate = $"{f.Field} != @{idx}";
                break;
            case "gt":
                predicate = $"{f.Field} > @{idx}";
                break;
            case "gte":
                predicate = $"{f.Field} >= @{idx}";
                break;
            case "lt":
                predicate = $"{f.Field} < @{idx}";
                break;
            case "lte":
                predicate = $"{f.Field} <= @{idx}";
                break;
            case "contains":
                // safest possible â€” works for any object type
                predicate = $"Convert.ToString({f.Field}).Contains(@{idx})";
                break;
            case "doesnotcontain":
                predicate = $"!Convert.ToString({f.Field}).Contains(@{idx})";
                break;
            case "startswith":
                predicate = $"Convert.ToString({f.Field}).StartsWith(@{idx})";
                break;
            case "endswith":
                predicate = $"Convert.ToString({f.Field}).EndsWith(@{idx})";
                break;
            default:
                predicate = $"{f.Field} == @{idx}";
                break;
        }

        parts.Add(predicate);

        // Normalize values (parse dates / numbers if needed)
        if (f.Value is JsonElement jsonValue)
        {
            if (jsonValue.ValueKind == JsonValueKind.String && DateTime.TryParse(jsonValue.GetString(), out var dt))
                values.Add(dt);
            else if (jsonValue.ValueKind == JsonValueKind.Number)
                values.Add(jsonValue.GetDecimal());
            else
                values.Add(jsonValue.ToString());
        }
        else
        {
            values.Add(f.Value ?? DBNull.Value);
        }
    }

    var logic = string.IsNullOrEmpty(descriptor.Logic) ? "and" : descriptor.Logic.ToLowerInvariant();
    var predicate = string.Join($" {logic} ", parts);

    return (predicate, values);
}
